#include <pybind11/eigen.h>
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>

#include "casm/crystallography/BasicStructure.hh"
#include "casm/crystallography/Lattice.hh"
#include "casm/crystallography/SimpleStructure.hh"
#include "casm/crystallography/SymType.hh"
#include "casm/mapping/AtomMapping.hh"
#include "casm/mapping/LatticeMapping.hh"
#include "casm/mapping/MappingSearch.hh"
#include "casm/mapping/StructureMapping.hh"
#include "casm/mapping/map_atoms.hh"
#include "casm/mapping/map_lattices.hh"
#include "casm/mapping/map_structures.hh"

#define STRINGIFY(x) #x
#define MACRO_STRINGIFY(x) STRINGIFY(x)

namespace py = pybind11;

/// CASM - Python binding code
namespace CASMpy {

using namespace CASM;
using namespace CASM::mapping;

}  // namespace CASMpy

PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>);

PYBIND11_MODULE(search, m) {
  using namespace CASMpy;

  m.doc() = R"pbdoc(
        casm.mapping.search
        ------------

        The casm.mapping.search module is a Python interface to the mapping
        search classes and methods in the CASM::mapping namespace of the CASM
        C++ libraries. This includes:

        - Methods for performing a search for mapping transformations that
          relate one structure to another

    )pbdoc";
  py::module::import("casm.xtal");
  py::module::import("casm.xtal.mapping");
  m.attr("TOL") = TOL;

  py::class_<PrimSearchData, std::shared_ptr<PrimSearchData>>(
      m, "PrimSearchData", R"pbdoc(
      Prim-related data used for mapping searches

      This object holds shared data for use by all mappings to a single
      Prim.

      )pbdoc")
      .def(py::init<std::shared_ptr<xtal::BasicStructure const>,
                    std::optional<std::vector<xtal::SymOp>>, bool>(),
           py::arg("prim"), py::arg("override_prim_factor_group"),
           py::arg("enable_symmetry_breaking_atom_cost"),
           R"pbdoc(
          Construct PrimSearchData

          Parameters
          ----------

          prim : casm.xtal.Prim
              A primitive reference "parent" structure that a structure
              may be mapped to
          override_prim_factor_group : List[casm.xtal.SymOp], optional
              Optional, allows explicitly setting the symmetry operations
              used to skip symmetrically equivalent structure mappings. The
              default (None), uses the prim factor group as generated by
              `casm.xtal.make_prim_factor_group`. The first symmetry
              operation should always be the identity operation. Will raise
              if an empty vector is provided.
          enable_symmetry_breaking_atom_cost : bool
              If symmetry_breaking_atom_cost is intended to be used, setting
              this to true will generate the symmetry-invariant displacement
              modes required for the calculation using this object's
              prim_factor_group.
          )pbdoc")
      .def(
          "prim", [](PrimSearchData const &m) { return m.prim; },
          "Return the prim.")
      .def(
          "prim_lattice",
          [](PrimSearchData const &m) { return m.prim_lattice; },
          "Return the lattice of the prim.")
      .def(
          "N_prim_site", [](PrimSearchData const &m) { return m.N_prim_site; },
          "Return the number of sites in the prim.")
      .def(
          "prim_site_coordinate_cart",
          [](PrimSearchData const &m) { return m.prim_site_coordinate_cart; },
          "Return the Cartesian coordinates of prim sites as columns of a "
          "shape=(3,N_prim_site) matrix.")
      .def(
          "prim_allowed_atom_types",
          [](PrimSearchData const &m) { return m.prim_allowed_atom_types; },
          "Return a size=N_prim_site array of arrays with the names of atoms "
          "allowed on each site in the prim.")
      .def(
          "prim_factor_group",
          [](PrimSearchData const &m) { return m.prim_factor_group; },
          "Return symmetry operations of the prim that may be used to skip "
          "symmetrically equivalent structure mappings.")
      .def(
          "prim_crystal_point_group",
          [](PrimSearchData const &m) { return m.prim_crystal_point_group; },
          "Return point group operations of the prim that may be used to skip "
          "symmetrically equivalent lattice mappings.")
      .def(
          "prim_sym_invariant_displacement_modes",
          [](PrimSearchData const &m) {
            return m.prim_sym_invariant_displacement_modes;
          },
          "Return a size=N_mode vector with shape=(3,N_prim_site) matrices, "
          "giving the symmetry invariant displacement modes. Columns of the "
          "matrices are the displacements associated with each site for a "
          "given mode.");

  py::class_<StructureSearchData, std::shared_ptr<StructureSearchData>>(
      m, "StructureSearchData", R"pbdoc(
      Struture-related data used for mapping searches

      This object holds shared data for use by all mappings of a
      single casm.xtal.Structure. Mapping may be performed of:
      - lattice orientation
      - lattice strain
      - site permutation
      - site atomic occupant type
      - site displacements

      Mapping of structures with molecular occupants and other types
      of properties (magentic spin, etc.) is not currently supported.

      )pbdoc")
      .def(py::init<xtal::Lattice const &, Eigen::MatrixXd const &,
                    std::vector<std::string>,
                    std::optional<std::vector<xtal::SymOp>>>(),
           py::arg("lattice"), py::arg("atom_coordinate_cart"),
           py::arg("atom_type"), py::arg("override_structure_factor_group"),
           R"pbdoc(
          Construct StructureSearchData

          Parameters
          ----------

          lattice : casm.xtal.Lattice
              The lattice of the structure being mapped
          atom_coordinate_cart : array_like, shape (3, n)
            Atom positions, as columns of a matrix, in Cartesian
            coordinates. May included coordinates of explicitly specified
            vacancies.
          atom_type : List[str], size=n
            Atom type names. May include explicitly specified vacancies,
            which should be named "Va", "va", or "VA".
          override_structure_factor_group : List[casm.xtal.SymOp], optional
              Optional, allows explicitly setting the symmetry operations
              of the structure which may be used to skip symmetrically
              equivalent structure mappings. The default (None), uses the
              factor group as generated by
              `casm.xtal.make_structure_factor_group` for the structure
              specified by `lattice`, `atom_coordinate_cart`, and
              `atom_type`. The first symmetry operation should always be
              the identity operation. Will raise if an empty vector is
              provided.
          enable_symmetry_breaking_atom_cost : bool
              If symmetry_breaking_atom_cost is intended to be used, setting
              this to true will generate the symmetry-invariant displacement
              modes required for the calculation using this object's
              prim_factor_group.
          )pbdoc")
      .def(
          "lattice", [](StructureSearchData const &m) { return m.lattice; },
          "Return the lattice of the structure being mapped.")
      .def(
          "N_atom", [](StructureSearchData const &m) { return m.N_atom; },
          "Return the number of atoms (and explicitly included vacancies) in "
          "the structure being mapped.")
      .def(
          "atom_coordinate_cart",
          [](StructureSearchData const &m) { return m.atom_coordinate_cart; },
          "Return the Cartesian coordinates, as columns of a shape=(3,N_atom) "
          "matrix, of atoms (and explicitly included vacancies) in the "
          "structure being mapped.")
      .def(
          "atom_type", [](StructureSearchData const &m) { return m.atom_type; },
          "Return a size=N_atom array of with the name of the atom (or "
          "explicitly included vacancy) at each site. Explicit specified "
          "vacancies should be given the name \"Va\", \"VA\", or \"va\".")
      .def(
          "structure_factor_group",
          [](StructureSearchData const &m) { return m.structure_factor_group; },
          "Return symmetry operations of the structure being mapped that may "
          "be used to skip symmetrically equivalent structure mappings.")
      .def(
          "structure_crystal_point_group",
          [](StructureSearchData const &m) {
            return m.structure_crystal_point_group;
          },
          "Return point group operations of the structure being mapped that "
          "may be used to skip symmetrically equivalent lattice mappings.");

  py::class_<LatticeMappingSearchData,
             std::shared_ptr<LatticeMappingSearchData>>(
      m, "LatticeMappingSearchData", R"pbdoc(
      Lattice mapping-related data used for mapping searches

      This object holds shared data for use by all structure mappings
      in the context of a single lattice mapping
      (`~casm.mapping.LatticeMapping`).
      )pbdoc")
      .def(py::init<std::shared_ptr<mapping::PrimSearchData const>,
                    std::shared_ptr<mapping::StructureSearchData const>,
                    mapping::LatticeMapping>(),
           py::arg("prim_data"), py::arg("structure_data"),
           py::arg("lattice_mapping"),
           R"pbdoc(
          Construct StructureSearchData

          Parameters
          ----------

          prim_data : casm.mapping.search.PrimSearchData
              Search data for a prim being mapped to
          structure_data : casm.mapping.search.StructureSearchData
              Search data for the structure being mapped
          lattice_mapping : casm.mapping.LatticeMapping
              Lattice mapping between the prim and structure.
          )pbdoc")
      .def(
          "prim_data",
          [](LatticeMappingSearchData const &m) { return m.prim_data; },
          "Return the search data for the prim being mapped to.")
      .def(
          "structure_data",
          [](LatticeMappingSearchData const &m) { return m.structure_data; },
          "Return the search data for the structure being mapped.")
      .def(
          "lattice_mapping",
          [](LatticeMappingSearchData const &m) { return m.lattice_mapping; },
          "Return the lattice mapping between the prim and structure.")
      .def(
          "transformation_matrix_to_super",
          [](LatticeMappingSearchData const &m) {
            return m.transformation_matrix_to_super;
          },
          R"pbdoc(
          Return the transformation matrix to the ideal superstructure lattice

          The transformation matrix that gives the ideal
          superstructure lattice, for this lattice mapping,
          from the prim lattice (i.e. T*N of the lattice
          mapping).

          This is equivalent to:

              lround(lattice_mapping.transformation_matrix_to_super *
                     lattice_mapping.reorientation)

          )pbdoc")
      .def(
          "supercell_lattice",
          [](LatticeMappingSearchData const &m) { return m.supercell_lattice; },
          R"pbdoc(
          Return the lattice of the ideal supercell.

          The lattice of the ideal supercell is :math:`S_1 = L_1 * T * N`
          as defined in `~casm.xtal.LatticeMapping`).
          )pbdoc")
      .def(
          "N_supercell_site",
          [](LatticeMappingSearchData const &m) { return m.N_supercell_site; },
          "Return the number of sites in the ideal superstructure specified by "
          "the lattice_mapping.")
      .def(
          "atom_coordinate_cart_in_supercell",
          [](LatticeMappingSearchData const &m) {
            return m.atom_coordinate_cart_in_supercell;
          },
          R"pbdoc(
          Return atom coordinates mapped to the lattice of the ideal supercell

          Return the shape=(3,N_supercell_site) matrix with columns
          containing the Cartesian coordinates of the structure's atoms
          in the state after the inverse lattice mapping deformation is
          applied (:math:`F^{-1}\vec{r_2}`, as defined in
          `~casm.xtal.AtomMapping`). The "supercell" refers to the
          lattice of the ideal supercell, `supercell_lattice`,
          :math:`S_1 = L_1 * T * N`, as defined in
          `~casm.xtal.LatticeMapping`).
          )pbdoc")
      .def(
          "supercell_site_coordinate_cart",
          [](LatticeMappingSearchData const &m) {
            return m.supercell_site_coordinate_cart;
          },
          "Return Cartesian coordinates of sites in the ideal "
          "supersuperstructure, as columns of a shape=(3,N_supercell_site) "
          "matrix.")
      .def(
          "supercell_allowed_atom_types",
          [](LatticeMappingSearchData const &m) {
            return m.supercell_allowed_atom_types;
          },
          "Return a size=N_supercell_site array of arrays with the names of "
          "atoms allowed on each site in the ideal superstructure.");

  m.def("make_trial_translations", &mapping::make_trial_translations,
        R"pbdoc(
        Return translations that bring atoms into registry with ideal superstructure sites.

        Atom mapping assignment is made by optimizing a cost that depends on
        site-to-atom displacements, `site_displacements`, that are calculated
        using the minimum length displacements that satisfy:

            supercell_site_coordinate_cart[i] + site_displacements[i][j] =
                F^{-1}*atom_coordinate_cart[j] + trial_translation_cart

        under periodic boundary conditions. The trial_translation may not be
        equal to the final :class:`~casm.mapping.AtomMapping` translation
        which is chosen after solving the atom assignment problem so that
        the mean displacement of the atom mapping is equal to zero.

        This function returns a minimal set of trial translations by finding
        an atom type with the fewest valid atom type -> allowed site
        translations and returning the corresponding translations. For each
        trial translation at least one site_displacement is of length zero.

        Parameters
        ----------
        lattice_mapping_data : casm.mapping.search.LatticeMappingSearchData
            Data describing a lattice mapping between a prim and a structure

        Returns
        -------
        trial_translations_cart : List[]
            An array holding a minimal set of trial translations, in
            Cartesian coordinates, which bring atoms of the structure
            being mapped into alignment with sites in the ideal
            superstructure of the prim they are being mapped to.
        )pbdoc");

  m.def("make_atom_to_site_cost", &make_atom_to_site_cost,
        R"pbdoc(
        Return the cost for mapping a particular atom to a particular site

        The mapping cost:

        - of a vacancy to any site that allows vacancies is set to
          0.0.
        - of an atom to a site that does not allow the atom type is
          infinity
        - otherwise, the mapping cost is equal to displacement length
          squared

        Notes
        -----
        Vacancies should be given the name \"Va\", \"VA\", or \"va\", and
        checked for with the function :func:`casm.xtal.is_vacancy`.

        Parameters
        ----------
        displacement : array_like, shape=(3,)
            The minimum length displacement, accounting for periodic
            boundaries, from the site to the atom.
        atom_type : str,
            The atom (or vacancy) type.
        allowed_atom_types : List[str]
            The atom (or vacancy) types allowed on the site.
        infinity: float, default=1e20
            The value to use for the cost of unallowed mappings

        Returns
        -------
        cost : float
            The atom (or vacancy) mapping cost.
        )pbdoc");

  py::class_<AtomMappingSearchData, std::shared_ptr<AtomMappingSearchData>>(
      m, "AtomMappingSearchData", R"pbdoc(
      Atom mapping-related data used for mapping searches

      Atom mapping assignment is made by optimizing a cost that depends on
      site-to-atom displacements, `site_displacements`, that are calculated
      using the minimum length displacements that satisfy:

          supercell_site_coordinate_cart[i] + site_displacements[i][j] =
              F^{-1}*atom_coordinate_cart[j] + trial_translation_cart

      under periodic boundary conditions. The trial_translation may not be
      equal to the final :class:`~casm.mapping.AtomMapping` translation
      which is chosen after solving the atom assignment problem so that
      the mean displacement of the atom mapping is equal to zero.

      This object stores a `trial_translation_cart`, `site_displacements`,
      and resulting `cost_matrix` used to find optimal atom-to-site
      assignment solutions in the context of a particular lattice mapping.
      )pbdoc")
      .def(py::init<std::shared_ptr<LatticeMappingSearchData const>,
                    Eigen::Vector3d const &, AtomToSiteCostFunction, double>(),
           py::arg("lattice_mapping_data"), py::arg("trial_translation_cart"),
           py::arg("atom_to_site_cost_f") =
               AtomToSiteCostFunction(make_atom_to_site_cost),
           py::arg("infinity") = 1e20, R"pbdoc(
          Construct AtomMappingSearchData

          Parameters
          ----------

          lattice_mapping_data : casm.mapping.search.LatticeMappingSearchData
              Search data for a particular lattice mapping between a prim and
              the structure being mapped.
          trial_translation_cart : array_like, shape=(3,)
              A Cartesian translation applied to atom coordinates in the
              ideal superstructure setting (i.e.
              atom_coordinate_cart_in_supercell) to bring the atoms and sites
              into alignment.
          atom_to_site_cost_f : function, optional
              A function used to calculate the cost of mapping an atom to a
              particular site. Follows the signature of
              :func:`~casm.mapping.search.make_atom_to_site_cost`, which is
              the default method.
          infinity : float, default=1e20
              The value to use for the cost of unallowed mappings.
          )pbdoc")
      .def(
          "lattice_mapping_data",
          [](AtomMappingSearchData const &m) { return m.lattice_mapping_data; },
          "Return the search data for the lattice mapping.")
      .def(
          "trial_translation_cart",
          [](AtomMappingSearchData const &m) {
            return m.trial_translation_cart;
          },
          "Return the Cartesian translation applied to atom coordinates in the "
          "ideal superstructure setting (i.e. "
          "atom_coordinate_cart_in_supercell) to bring the atoms into "
          "alignment with ideal superstructure sites.")
      .def(
          "site_displacements",
          [](AtomMappingSearchData const &m) { return m.site_displacements; },
          R"pbdoc(
          Return the site-to-atom displacements of minimum length under periodic boundary conditions of the ideal superstructure.

          The displacements are indexed using
          `site_displacements[site_index][atom_index]`, where the `site_index`
          and `atom_index` are indices into the columns of
          `lattice_mapping_data.supercell_site_coordinate_cart()` and
          `lattice_mapping_data.atom_coordinate_cart_in_supercell()`,
          respectively.
          )pbdoc")
      .def(
          "cost_matrix",
          [](AtomMappingSearchData const &m) { return m.cost_matrix; },
          R"pbdoc(
          Returns a shape=(N_supercell_site, N_supercell_site) cost matrix used in the atom to site assignment problem.

          The element `cost_matrix(site_index, atom_index)` is set to the
          cost of mapping a particular atom onto a particular site, where
          the indices are into the columns of
          `lattice_mapping_data.supercell_site_coordinate_cart()` and
          `lattice_mapping_data.atom_coordinate_cart_in_supercell()`,
          respectively.
          )pbdoc");

  py::class_<MappingNode>(m, "MappingNode", R"pbdoc(
      A node in the search for optimal structure mappings

      This encodes a particular prim, lattice mapping, and atom mapping,
      and includes the information needed to continue searching for
      suboptimal assignments. It is constructed in the context of a
      :class:`~casm.mapping.search.MappingSearch`, and not on its own.
      )pbdoc")
      .def(py::init(&make_mapping_node), py::arg("search"),
           py::arg("lattice_cost"), py::arg("lattice_mapping_data"),
           py::arg("trial_translation_cart"),
           py::arg("forced_on") = std::map<Index, Index>(),
           py::arg("forced_off") = std::vector<std::pair<Index, Index>>(),
           R"pbdoc(
          Construct a MappingNode

          Given any assignment constraints (`forced_on` and `forced_off`), and

          Parameters
          ----------
          search : casm.mapping.search.MappingSearch
              A :class:`~casm.mapping.search.MappingSearch` method.
          lattice_cost : float
              The lattice mapping cost.
          lattice_mapping_data : casm.mapping.search.LatticeMappingSearchData
              Search data for a particular lattice mapping between a prim and
              the structure being mapped.
          atom_mapping_data : casm.mapping.search.AtomMappingSearchData
              Search data for a particular lattice mapping and choice of
              trial translation between a prim and the structure being mapped.
          forced_on : Dict[int, int]
              A map of assignments `site_index: atom_index` that are forced
              on.
          forced_off : List[Tuple[int, int]]
              A list of tuples of assignments `(site_index, atom_index)` that
              are forced off.
          )pbdoc")
      .def(
          "lattice_cost", [](MappingNode const &m) { return m.lattice_cost; },
          "Return the lattice mapping cost.")
      .def(
          "lattice_mapping_data",
          [](MappingNode const &m) { return m.lattice_mapping_data; },
          "Return the search data for the lattice mapping.")
      .def(
          "atom_cost", [](MappingNode const &m) { return m.atom_cost; },
          "Return the atom mapping cost.")
      .def(
          "atom_mapping_data",
          [](MappingNode const &m) { return m.atom_mapping_data; },
          "Return the search data for a particular lattice mapping and choice "
          "of trial translation between a prim and the structure being mapped.")
      .def(
          "atom_mapping", [](MappingNode const &m) { return m.atom_mapping; },
          "Return the atom mapping transformation.")
      .def(
          "forced_on",
          [](MappingNode const &m) { return m.assignment_node.forced_on; },
          "Return a map of assignments `site_index: atom_index` that are "
          "forced on.")
      .def(
          "forced_off",
          [](MappingNode const &m) { return m.assignment_node.forced_on; },
          "Return a list of tuples of assignments `(site_index, atom_index)` "
          "that are forced off.");

  py::class_<MappingSearch>(m, "MappingSearch", R"pbdoc(
      Used to perform structure mapping searches

      The MappingSearch class holds parameters, data,
      and methods used to search for low cost structure mappings.

      It holds a queue of :class:`~casm.mapping.search.MappingNode`,
      which encode a particular structure mapping, and the data
      necessary to start from that structure mapping and find
      sub-optimal atom mappings as part of a search using the Murty
      Algorithm to find sub-optimal atom-to-site assignments.

      It also holds the best results found so far which satisfy
      some acceptance criteria:

      - min_cost: Keep mappings with total cost >= min_cost
      - max_cost: Keep mappings with total cost <= max_cost
      - k_best: Keep the k_best mappings with lowest total cost
        that also satisfy the min/max cost criteria. Approximate
        ties with the current k_best result are also kept.

      Overview of methods:

      - To begin, :func:`~casm.mapping.search.MappingSearch.make_and_insert_mapping_node` is called one or more times to generate initial structure mapping solutions given a particular lattice mapping and choice of trial translation to bring atoms into alignment with sites that they might be mapped to. Each call adds one node (think one structure mapping) to the MappingSearch queue and, potentially, to the MappingSearch results (if the cost range and k-best acceptance criterais are satisfied).
      - Then, :func:`~casm.mapping.search.MappingSearch.partition` is called repeatedly to search for sub-optimal cost mapping solutions. Each partition creates 0 or more nodes (structure mappings with sub-optimal atom assignment solutions) which are inserted into the MappingSearch queue and, potentially, to the MappingSearch results (if the cost range and k-best acceptance criterais are satisfied).
      - The methods :func:`~casm.mapping.search.MappingSearch.front`, :func:`~casm.mapping.search.MappingSearch.back`, :func:`~casm.mapping.search.MappingSearch.pop_front`, :func:`~casm.mapping.search.MappingSearch.pop_back`, and :func:`~casm.mapping.search.MappingSearch.size` allow managing
        the MapppingSearch queue.


      Notes
      -----
      The :class:`~casm.mapping.search.QueueConstraints` class is example of
      approach to manage the MappingSearch queue during a search.
      )pbdoc")
      .def(py::init<double, double, int, AtomCostFunction, TotalCostFunction,
                    AtomToSiteCostFunction, double, double>(),
           py::arg("min_cost") = 0.0, py::arg("max_cost") = 1e20,
           py::arg("k_best") = 1, py::arg("atom_cost_f") = IsotropicAtomCost(),
           py::arg("total_cost_f") = WeightedTotalCost(0.5),
           py::arg("atom_to_site_cost_f") =
               AtomToSiteCostFunction(make_atom_to_site_cost),
           py::arg("infinity") = 1e20, py::arg("cost_tol") = 1e-5,
           R"pbdoc(
          Construct a MappingSearch

          Parameters
          ----------
          min_cost : float, default=0.0
              Keep mappings with total cost >= min_cost.
          max_cost : float, default=1e20
              Keep mappings with total cost <= max_cost.
          k_best : int, default=1
              Keep the k_best mappings with lowest total cost that also
              satisfy the min/max cost criteria. Approximate ties with the
              current k_best result are also kept.
          atom_cost_f : function, default=`~casm.mapping.search.IsotropicAtomCost()`
              Function used to calculate the atom mapping cost. Expected to
              match the same signature as :class:`~casm.mapping.search.IsotropicAtomCost`.
              Possible atom mapping cost functions:

              - :class:`~casm.mapping.search.IsotropicAtomCost`
              - :class:`~casm.mapping.search.SymmetryBreakingAtomCost`

          total_cost_f : function, default=`~casm.mapping.search.WeightedTotalCost()`
              Function used to calculate the total mapping cost. Expected to
              match the same signature as :class:`~casm.mapping.search.WeightedTotalCost`.
              Possible total mapping cost functions:

              - :class:`~casm.mapping.search.WeightedTotalCost()`

          atom_to_site_cost_f : function, default=:function:`~casm.mapping.search.make_atom_to_site_cost`
              Function used to calculate the elements of the assignment problem cost
              matrix. Expected to match the same signature as :function:`~casm.mapping.search.make_atom_to_site_cost`.
              Possible atom-to-site mapping cost functions:

              - :class:`~casm.mapping.search.WeightedTotalCost()`

          infinity : float, default=1e20
              The value to use in the assignment problem cost matrix for
              unallowed atom-to-site mappings.

          cost_tol : float, default=1e20
              Tolerance for checking if mapping costs are approximately equal.
          )pbdoc")
      .def("front", &MappingSearch::front,
           "Return a reference to the lowest cost MappingNode in the queue.")
      .def("back", &MappingSearch::back,
           "Return a reference to the highest cost MappingNode in the queue.")
      .def("pop_front", &MappingSearch::pop_front,
           "Erase the lowest cost MappingNode in the queue.")
      .def("pop_back", &MappingSearch::pop_back,
           "Erase the highest cost MappingNode in the queue.")
      .def("size", &MappingSearch::size, "Return the current queue size.")
      .def("make_and_insert_mapping_node",
           &MappingSearch::make_and_insert_mapping_node,
           py::arg("lattice_cost"), py::arg("lattice_mapping_data"),
           py::arg("trial_translation_cart"), py::arg("forced_on"),
           py::arg("forced_off"),
           R"pbdoc(
          Make and insert a mapping solution

          The (constrained) assignment problem is solved in context of
          a particular lattice mapping and trial translation, and
          the resulting AtomMapping, atom mapping cost, and total cost
          are stored in a MappingNode. The MappingNode is inserted into
          the MappingSearch queue. It is also inserted into the
          MappingSearch results, if it satisifies the cost range and
          k-best criteria.

          Parameters
          ----------
          lattice_cost : float
              The cost of the lattice mapping that forms the context
              in which atom mappings are solved.
          lattice_mapping_data : casm.mapping.search.LatticeMappingSearchData
              Holds the lattice mapping and related data that forms the context
              in which atom mappings are solved.
          trial_translation_cart : array_like, shape=(3,)
              A Cartesian translation applied to atom coordinates in the
              ideal superstructure setting (i.e.
              atom_coordinate_cart_in_supercell) to bring the atoms and sites
              into alignment.
          forced_on : Dict[int, int]
              A map of assignments `site_index: atom_index` that are forced
              on.
          forced_off : List[Tuple[int, int]]
              A list of tuples of assignments `(site_index, atom_index)` that
              are forced off.
          )pbdoc")
      .def("partition", &MappingSearch::partition,
           R"pbdoc(
          Make and insert sub-optimal mapping solutions

          The Murty algorithm is used to generate sub-optimal assignments
          from the current lowest cost solution in the queue (available as :func:`~casm.mapping.search.MappingSearch.front`). The
          resulting MappingNode are inserted into the MappingSearch queue.
          They are also inserted into the MappingSearch results, if they
          satisify the cost range and k-best criteria. Finally,
          :func:`~casm.mapping.search.MappingSearch.pop_front` is called.
          )pbdoc");

#ifdef VERSION_INFO
  m.attr("__version__") = MACRO_STRINGIFY(VERSION_INFO);
#else
  m.attr("__version__") = "dev";
#endif
}
